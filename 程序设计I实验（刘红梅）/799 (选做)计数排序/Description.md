# (选做)计数排序

# Description:

bitmap是一种特殊的数据结构，主要可以用作对不重复的大量非负数进行排序。主要实现思想是这样的：

1. 首先初始化一串长度为N（假设是10000000）的字符串S的所有位置为0，N应该不小于这些大量正整数的最大值。

2. 接着遍历这些所有的正整数，对于每一个非负数进行这样的操作：如果这个正整数是100，就在字符串S的第100个位置置1，那么类似的如果这个正整数是1000，就在S的第1000位置1。

3. 最后，按序输出S所有为1的位置的下标即可（从小到大排序为从低位到高位的顺序，反之高位到低位）。

 

对于bitmap有一种表示方式：我们知道int型的数占用32位的空间。我们可以用一个int的数组来表示这个长度为N的bitmap，例如如果N=65，那么只需要长度为3的int数组即可表示它（因为长度为3的int数组占用32*3>65的空间），类似的对于N我们只需要长度为N/32+1的int数组即可表示它。

 

下面我们看一个具体的例子：

假设有5个测试数据：4 50 3 1 2。那么N=50即可，也即需要长度为50/32+1=2的int数组。

1. 首先，将这个数组初始化为每一个位都为0；

2. for（每一个测试数据num） {

        把num对应的二进制bit位置1（例如当num=4时，需要把int数组的第4/32=0个位置的数的第4%32的位置置1；类似的当num=50时，需要把int数组的第50/32=1个位置的数的第50%32=18个bit位置1。）

}

此时，这个int数组的二进制应该是：00000000 00000010 00000000 00000000，00000000 00000000 00000000 00011110，因为第4，50，3，1，2位置的bit被置1.

3. 最后，从低位到高位遍历，输出这个bitmap对应的bit位置是1的位置的下标即完成了从小到大的排序

 

只需提交子函数即可，**不需提交main函数**。建议根据提示的子函数的功能实现子函数

# Input
第一行为待排序数字个数

第二行为待排序数字，最大不超过10000000

**注意，只有一行待排序数字**

# Output
排序后的数

# Sample Input
```
9
4 5 6 1 2 3 9999999 100 0

```

# Sample Output
```
0 1 2 3 4 5 6 100 9999999 

```


# Hint
此题的主要目的是希望同学们学习这种高效的排序方法（此排序方法的复杂度为o(N)，但仅适用于不重复的非负数，对海量数据排序的优化效果更明显）

**另外**，这题涉及到位操作，[位操作，重点看左移和右移操作](http://baike.baidu.com/link?url=BXYmo6aab18sLexIEZaX68AXr39SFUtlr_N-WTP7QGPQJ7k_acX96bq2LDOOp4X44Fxa_VEXAXfcqSR1vsjXc5n0XvCt4J5C5brdJKJ96aVPjgErrne8c8hFPBLhXvnT)